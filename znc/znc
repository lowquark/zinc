#!/usr/bin/lua

local pprint = require 'pprint'

--------------------------------------------------------------------------------
-- AST
--------------------------------------------------------------------------------

local function ast_name_path()
  return { }
end

-- Expressions: (The list is long)
local function ast_expr_integer(value)
  return { type = 'integer', value = value }
end
local function ast_expr_variable(name)
  return { type = 'variable', name = name }
end

local function ast_expr_negate(subexpr)
  return { type = 'negate', expression = subexpr }
end
local function ast_expr_binnot(subexpr)
  return { type = 'binnot', expression = subexpr }
end
local function ast_expr_lognot(subexpr)
  return { type = 'lognot', expression = subexpr }
end

local function ast_expr_add(subexpr_a, subexpr_b)
  return { type = 'add', expression_a = subexpr_a, expression_b = subexpr_b }
end
local function ast_expr_sub(subexpr_a, subexpr_b)
  return { type = 'sub', expression_a = subexpr_a, expression_b = subexpr_b }
end
local function ast_expr_mul(subexpr_a, subexpr_b)
  return { type = 'mul', expression_a = subexpr_a, expression_b = subexpr_b }
end
local function ast_expr_div(subexpr_a, subexpr_b)
  return { type = 'div', expression_a = subexpr_a, expression_b = subexpr_b }
end

local function ast_expr_cmpeq(subexpr_a, subexpr_b)
  return { type = 'cmpeq', expression_a = subexpr_a, expression_b = subexpr_b }
end
local function ast_expr_cmpneq(subexpr_a, subexpr_b)
  return { type = 'cmpneq', expression_a = subexpr_a, expression_b = subexpr_b }
end
local function ast_expr_cmplt(subexpr_a, subexpr_b)
  return { type = 'cmplt', expression_a = subexpr_a, expression_b = subexpr_b }
end
local function ast_expr_cmpgt(subexpr_a, subexpr_b)
  return { type = 'cmpgt', expression_a = subexpr_a, expression_b = subexpr_b }
end
local function ast_expr_cmpleq(subexpr_a, subexpr_b)
  return { type = 'cmpleq', expression_a = subexpr_a, expression_b = subexpr_b }
end
local function ast_expr_cmpgeq(subexpr_a, subexpr_b)
  return { type = 'cmpgeq', expression_a = subexpr_a, expression_b = subexpr_b }
end

local function ast_expr_logand(subexpr_a, subexpr_b)
  return { type = 'logand', expression_a = subexpr_a, expression_b = subexpr_b }
end
local function ast_expr_logor(subexpr_a, subexpr_b)
  return { type = 'logor', expression_a = subexpr_a, expression_b = subexpr_b }
end

-- Statements: block | local | if | return | assign | call
local function ast_stmt_block()
  return { type = 'block' }
end
local function ast_stmt_local_declaration(type_name_path, name)
  return { type = 'local', type_name_path = type_name_path, name = name }
end
local function ast_stmt_if(expr, if_stmt, else_stmt)
  return { type = 'if', expression = expr, if_statement = if_stmt, else_statement = else_stmt }
end
local function ast_stmt_return(expr)
  return { type = 'return', expression = expr }
end
local function ast_stmt_assign(name, expr)
  return { type = 'assign', name = name, expression = expr }
end
local function ast_stmt_function_call(name_path, arg_list)
  return { type = 'call', name_path = name_path, argument_list = arg_list }
end

-- Struct declarations: field | access
local function ast_struct_field_declaration(type_name_path, name)
  return { type = 'field', type_name_path = type_name_path, name = name }
end
local function ast_struct_access_declaration(module_name_path)
  return { type = 'access', name_path = module_name_path }
end

-- Module declarations: member | function
local function ast_member_declaration(type_name_path, name)
  return { type = 'member', type_name_path = type_name_path, name = name }
end
local function ast_function_declaration(name, arguments, block)
  return { type = 'function', name = name, arguments = arguments, block = block }
end

-- File-scope declarations: struct | module
local function ast_struct_declaration(name_path, declarations)
  return { type = 'struct', name_path = name_path, declarations = declarations }
end
local function ast_module_declaration(name_path, declarations)
  return { type = 'module', name_path = name_path, declarations = declarations }
end

local ast_dump_expr
local ast_dump_stmt

ast_dump_expr = function(expr, level)
  local level = level or 0
  local indent = string.rep('  ', level)
  io.write(indent..string.upper(expr.type)..' ')
  if expr.value then
    io.write(tostring(expr.value)..'\n')
  elseif expr.name then
    io.write(expr.name..'\n')
  else
    io.write('\n')
  end
  if expr.expression then
    ast_dump_expr(expr.expression, level+1)
  elseif expr.expression_a and expr.expression_b then
    ast_dump_expr(expr.expression_a, level+1)
    ast_dump_expr(expr.expression_b, level+1)
  end
end

ast_dump_stmt = function(stmt, level)
  local level = level or 0
  local indent = string.rep('  ', level)
  if stmt.type == 'return' then
    io.write(indent..'RETURN\n')
    if stmt.expression then
      ast_dump_expr(stmt.expression, level+1)
    end
  elseif stmt.type == 'assign' then
    io.write(indent..'ASSIGN '..stmt.name..'\n')
    ast_dump_expr(stmt.expression, level+1)
  elseif stmt.type == 'local' then
    io.write(indent..'LOCAL '..stmt.name..' : '..table.concat(stmt.type_name_path,':')..'\n')
  elseif stmt.type == 'if' then
    io.write(indent..'IF\n')
    ast_dump_expr(stmt.expression, level+1)
    io.write(indent..'THEN\n')
    ast_dump_stmt(stmt.if_statement, level+1)
    if stmt.else_statement then
      io.write(indent..'ELSE\n')
      ast_dump_stmt(stmt.else_statement, level+1)
    end
  elseif stmt.type == 'block' then
    io.write(indent..'BLOCK\n')
    for i,block_stmt in ipairs(stmt) do
      ast_dump_stmt(block_stmt, level+1)
    end
  elseif stmt.type == 'call' then
    io.write(indent..'CALL '..table.concat(stmt.name_path,':')..'\n')
    for i,arg_expr in ipairs(stmt.argument_list) do
      ast_dump_expr(arg_expr, level+1)
    end
  end
end

function ast_dump_module_decl(decl, level)
  local level = level or 0
  local indent = string.rep('  ', level)
  if decl.type == 'function' then
    io.write(indent..'FUNCTION '..decl.name..' ( ')
    for i,arg in ipairs(decl.arguments) do
      io.write(arg.name..':'..table.concat(arg.type_name_path,':')..' ')
    end
    io.write(') -> ( ')
    -- ...
    io.write(')\n')
    ast_dump_stmt(decl.block, level + 1)
  elseif decl.type == 'member' then
    io.write(indent..'MEMBER '..decl.name..' : '..table.concat(decl.type_name_path,':')..'\n')
  else
    error('unknown decl declaration type `'..decl.type..'`')
  end
end

function ast_dump_module(module, level)
  local level = level or 0
  local indent = string.rep('  ', level)
  io.write(indent..'MODULE '..table.concat(module.name_path,':')..'\n')
  for i,decl in ipairs(module.declarations) do
    ast_dump_module_decl(decl, level + 1)
  end
end

function ast_dump_struct_decl(decl, level)
  local level = level or 0
  local indent = string.rep('  ', level)
  if decl.type == 'access' then
    io.write(indent..'ACCESS '..table.concat(decl.name_path,':')..'\n')
  elseif decl.type == 'field' then
    io.write(indent..'FIELD '..decl.name..' : '..table.concat(decl.type_name_path,':')..'\n')
  else
    error('unknown struct declaration type `'..decl.type..'`')
  end
end

function ast_dump_struct(struct, level)
  local level = level or 0
  local indent = string.rep('  ', level)
  io.write(indent..'STRUCT '..table.concat(struct.name_path,':')..'\n')
  for i,decl in ipairs(struct.declarations) do
    ast_dump_struct_decl(decl, level + 1)
  end
end

function ast_dump_file_decl(decl, level)
  local level = level or 0
  local indent = string.rep('  ', level)
  if decl.type == 'struct' then
    ast_dump_struct(decl, level)
  elseif decl.type == 'module' then
    ast_dump_module(decl, level)
  else
    error('unknown file-scope declaration type '..decl.type)
  end
end

local function ast_dump(ast, level)
  for i,decl in ipairs(ast) do
    ast_dump_file_decl(decl, 0)
  end
end

--------------------------------------------------------------------------------
-- Lexer
--------------------------------------------------------------------------------

local function Lexer(file)
  local L = { line = 1, col = 1 }

  local function print_token(tok)
    if tok.value then
      io.write('type: `'..tok.type..'` value: `'..tok.value..'`\n')
    else
      io.write('type: `'..tok.type..'`\n')
    end
  end

  local function yield(token)
    L.next = token
    -- Uncomment to print every token encountered
    --print_token(token)
    coroutine.yield(token)
  end

  local function readc()
    L.col = L.col + 1
    return file:read(1)
  end

  setmetatable(L, { __index = {
    read = coroutine.wrap(function(self)
      local c = readc()
      while true do
        if not c then
          yield { type = 'eof' }
        elseif string.match(c, '[%a_]') then
          -- This is a name or reserved keyword
          str = c
          c = readc()
          -- Keep matching, allowing decimals now
          while string.match(c, '[%w_]') do
            str = str .. c
            c = readc()
          end
          if str == 'access' then
            yield { type = 'access' }
          elseif str == 'module' then
            yield { type = 'module' }
          elseif str == 'struct' then
            yield { type = 'struct' }
          elseif str == 'function' then
            yield { type = 'function' }
          elseif str == 'return' then
            yield { type = 'return' }
          elseif str == 'if' then
            yield { type = 'if' }
          elseif str == 'else' then
            yield { type = 'else' }
          else
            yield { type = 'name', value = str }
          end
        elseif string.match(c, '%d') then
          -- This is a number
          str = c
          c = readc()
          -- Keep matching
          while string.match(c, '[%d]') do
            str = str .. c
            c = readc()
          end
          yield { type = 'integer', value = str }
        elseif c == '{' then
          c = readc()
          yield { type = 'lcurly' }
        elseif c == '}' then
          c = readc()
          yield { type = 'rcurly' }
        elseif c == '(' then
          c = readc()
          yield { type = 'lparen' }
        elseif c == ')' then
          c = readc()
          yield { type = 'rparen' }
        elseif c == ';' then
          c = readc()
          yield { type = 'semicolon' }
        elseif c == ':' then
          c = readc()
          yield { type = 'colon' }
        elseif c == '.' then
          c = readc()
          yield { type = 'dot' }
        elseif c == ',' then
          c = readc()
          yield { type = 'comma' }
        elseif c == '+' then
          c = readc()
          yield { type = 'plus' }
        elseif c == '-' then
          c = readc()
          yield { type = 'minus' }
        elseif c == '*' then
          c = readc()
          yield { type = 'asterisk' }
        elseif c == '/' then
          c = readc()
          yield { type = 'fslash' }
        elseif c == '~' then
          c = readc()
          yield { type = 'tilde' }
        elseif c == '!' then
          c = readc()
          if c == '=' then
            c = readc()
            yield { type = 'cmpneq' }
          else
            yield { type = 'lognot' }
          end
        elseif c == '<' then
          c = readc()
          if c == '=' then
            c = readc()
            yield { type = 'cmpleq' }
          else
            yield { type = 'cmplt' }
          end
        elseif c == '>' then
          c = readc()
          if c == '=' then
            c = readc()
            yield { type = 'cmpgeq' }
          else
            yield { type = 'cmpgt' }
          end
        elseif c == '&' then
          c = readc()
          if c == '&' then
            c = readc()
            yield { type = 'logand' }
          else
            yield { type = 'binand' }
          end
        elseif c == '|' then
          c = readc()
          if c == '|' then
            c = readc()
            yield { type = 'logor' }
          else
            yield { type = 'binor' }
          end
        elseif c == '=' then
          c = readc()
          if c == '=' then
            c = readc()
            yield { type = 'cmpeq' }
          else
            yield { type = 'equals' }
          end
        elseif c == '\n' then
          c = readc()
          self.line = self.line + 1
          self.col = 0
        else
          c = readc()
        end
      end
      file:close()
    end),
    close = function(self)
      file:close()
    end
  }})

  L:read()

  return L
end

--------------------------------------------------------------------------------
-- Parser
--------------------------------------------------------------------------------

--[[

Full parser grammar, in extended BNF:

<name-path-cdr> := { ':' <name> }
<name-path> := <name> <name-path-cdr>

<expression-p0> := '(' <expression> ')'
               | ( '-' | '~' | '!' ) <expression-p0> 
               | <integer> 
               | <name>
<expression-p1> := <expression-p0> { ( '*' | '/' ) <expression-p0> }
<expression-p2> := <expression-p1> { ( '+' | '-' ) <expression-p1> }
<expression-p3> := <expression-p2> { ( '<' | '>' | '<=' | '>=' ) <expression-p2> }
<expression-p4> := <expression-p3> { ( '==' | '!=' ) <expression-p3> }
<expression-p5> := <expression-p4> { '&&' <expression-p4> }
<expression-p6> := <expression-p5> { '||' <expression-p5> }
<expression> := <expression-p6>

<argument-list> := <expression> { ',' <expression> }
<argument-declaration-list> := <name-path> <name> { ',' <name-path> <name> }

<if-body> := 'if' '(' <expression> ')' <block>
<else-body> := 'else' ( <if-body> [ <else-body> ] | <block> )
<if-statement> := <if-body> [ <else-body> ]

<statement-post-name-path> := <name> ';' | '(' [ <argument-list> ] ')' ';'
<statement-post-name> := '=' <expression> ';' | <name-path-cdr> <statement-post-name-path>
<statement> := 'return' [ <expression> ] ';'
             | <if-statement>
             | <block>
             | <name> <statement-post-name>
             | <expression> ';'

<block> := '{' { <statement> } '}'

<function-declaration> := 'function' <name> '(' ')' <block>
<member-declaration> := <name-path> <name> ';'
<module-body-declaration> := <function-declaration> | <member-declaration>
<module-declaration> := 'module' <name-path> '{' { <module-body-declaration> } '}'

<access-declaration> := 'access' <name-path> ';'
<field-declaration> := <name-path> <name> ';'
<struct-body-declaration> := <access-declaration> | <field-declaration>
<struct-declaration> := 'struct' <name-path> '{' { <struct-body-declaration> } '}'

<file-scope-declaration> := <struct-declaration> | <module-declaration>

]]

local token_type_strings = {
  [ 'eof' ]       = 'EOF',
  [ 'name' ]      = 'name',
  [ 'access' ]    = 'access keyword',
  [ 'struct' ]    = 'struct keyword',
  [ 'module' ]    = 'module keyword',
  [ 'function' ]  = 'function keyword',
  [ 'return' ]    = 'return keyword',
  [ 'if' ]        = 'if keyword',
  [ 'else' ]      = 'else keyword',
  [ 'integer' ]   = 'integer constant',
  [ 'lcurly' ]    = '`{`',
  [ 'rcurly' ]    = '`}`',
  [ 'lparen' ]    = '`(`',
  [ 'rparen' ]    = '`)`',
  [ 'integer' ]   = 'integer constant',
  [ 'semicolon' ] = '`;`',
  [ 'dot' ]       = '`.`',
  [ 'plus' ]      = '`+`',
  [ 'minus' ]     = '`-`',
  [ 'asterisk' ]  = '`*`',
  [ 'fslash' ]    = '`/`',
  [ 'tilde' ]     = '`~`',
  [ 'cmpneq' ]    = '`!=`',
  [ 'lognot' ]    = '`!`',
  [ 'cmpleq' ]    = '`<=`',
  [ 'cmplt' ]     = '`<`',
  [ 'cmpgeq' ]    = '`>=`',
  [ 'cmpgt' ]     = '`>`',
  [ 'logand' ]    = '`&&`',
  [ 'binand' ]    = '`&`',
  [ 'logor' ]     = '`||`',
  [ 'binor' ]     = '`|`',
  [ 'cmpeq' ]     = '`==`',
  [ 'equals' ]    = '`=`',
}

-- Prints a parse error message and exits.
-- The printed error message contains the line and column number of the current lexer position, and indicates which
-- token was unexpected and which (given) tokens would have been valid.
--     L : Lexer state
--   ... : Valid token type strings
local function parse_abort_expected(L, ...)
  local expstr = ''
  local n = select('#', ...)
  for i=1,n do
    local v = select(i, ...)
    expstr = expstr..(token_type_strings[v] or v)
    if i == n - 1 then
      expstr = expstr..' or '
    elseif i ~= n then
      expstr = expstr..', '
    end
  end
  actstr = token_type_strings[L.next.type]
  io.write('Error on line '..L.line..', col '..L.col..': Expected '..expstr..'; got '..actstr..'\n')
  io.write(debug.traceback())
  os.exit(3)
end

-- Unless otherwise specified,
--   * Functions of the form expect_xxxx throw an error if the next token is not valid to start rule
--   xxxx.
--   * Functions of the form parse_xxxx return nil if the next token is not valid to start rule
--   xxxx.

-- Tries to parse a token of the given type
local function parse_token(L, type)
  if L.next.type == type then
    L:read()
    return true
  else
    return false
  end
end

-- Expects to parse a token of the given type
local function expect_token(L, type)
  if not parse_token(L, type) then
    parse_abort_expected(L, type)
  end
  return true
end

-- Tries to parse a <name> token
local function parse_name(L)
  if L.next.type == 'name' then
    local name = L.next.value
    L:read()
    return name
  end
end

-- Expects to parse a <name> token
local function expect_name(L)
  local name = parse_name(L)
  if not name then
    parse_abort_expected(L, 'name')
  end
  return name
end

-- Tries to parse the rule: <name-path-cdr>
-- Returns the AST object for a name path, using leading_name as the top-level name
local function parse_name_path_rest(L, leading_name)
  local name_path = ast_name_path()
  table.insert(name_path, leading_name)
  while parse_token(L, 'colon') do
    table.insert(name_path, expect_name(L))
  end
  return name_path
end

-- Tries to parse the rule: <name-path>
-- Returns the AST object for a name path
local function parse_name_path(L)
  local name = parse_name(L)
  if name then
    return parse_name_path_rest(L, name)
  end
end

-- Expects to parse the rule: <name-path>
-- Returns the AST object for a name path
local function expect_name_path(L)
  return parse_name_path_rest(L, expect_name(L))
end

-- Tries to parse the rule: <struct-access-declaration>
-- Returns the AST object for a struct access declaration
local function parse_struct_access_declaration(L)
  if parse_token(L, 'access') then
    local name_path = expect_name_path(L)
    expect_token(L, 'semicolon')
    return ast_struct_access_declaration(name_path)
  end
end

-- Tries to parse the rule: <struct-field-declaration>
-- Returns the AST object for a struct field declaration
local function parse_struct_field_declaration(L)
  local type_name_path = parse_name_path(L)
  if type_name_path then
    local name = expect_name(L)
    expect_token(L, 'semicolon')
    return ast_struct_field_declaration(type_name_path, name)
  end
end

-- Expects to parse the rule: <struct-access-declaration>
-- Returns the appropriate AST object for the declaration
local function expect_struct_body_declaration(L)
  local decl = parse_struct_access_declaration(L)
  if decl then return decl end
  decl = parse_struct_field_declaration(L)
  if decl then return decl end
  parse_abort_expected(L, 'field/access declaration')
end

-- Tries to parse the rule: <struct-declaration>
-- Returns the AST object for a struct declaration
local function parse_struct_declaration(L)
  local name_path 
  local declarations = {}
  if parse_token(L, 'struct') then
    local name_path = expect_name_path(L)
    expect_token(L, 'lcurly')
    while not parse_token(L, 'rcurly') do
      table.insert(declarations, expect_struct_body_declaration(L))
    end
    return ast_struct_declaration(name_path, declarations)
  end
end

local parse_expression

-- Tries to parse the rule: <expression-p0>
-- Returns the AST object for an expression
function parse_expression_p0(L)
  if L.next.type == 'lparen' then
    L:read()
    local subexpr = parse_expression(L)
    expect_token(L, 'rparen')
    return subexpr
  elseif L.next.type == 'minus' then
    L:read()
    local subexpr = parse_expression_p0(L)
    return ast_expr_negate(subexpr)
  elseif L.next.type == 'tilde' then
    L:read()
    local subexpr = parse_expression_p0(L)
    return ast_expr_binnot(subexpr)
  elseif L.next.type == 'lognot' then
    L:read()
    local subexpr = parse_expression_p0(L)
    return ast_expr_lognot(subexpr)
  elseif L.next.type == 'integer' then
    local value = L.next.value
    L:read()
    return ast_expr_integer(value)
  elseif L.next.type == 'name' then
    local name = L.next.value
    L:read()
    return ast_expr_variable(name)
  else
    return nil
  end
end

-- Tries to parse the rule: <expression-p1>
-- Returns the AST object for an expression
function parse_expression_p1(L)
  -- Read first operator argument (may be the only one)
  local subexpr = parse_expression_p0(L)
  while L.next.type == 'asterisk' or L.next.type == 'fslash' do
    -- Read operator
    local optype = L.next.type
    L:read()
    -- Read second operator argument
    local subexpr2 = parse_expression_p0(L)
    if optype == 'asterisk' then
      subexpr = ast_expr_mul(subexpr, subexpr2)
    elseif optype == 'fslash' then
      subexpr = ast_expr_div(subexpr, subexpr2)
    end
  end
  return subexpr
end

-- Tries to parse the rule: <expression-p2>
-- Returns the AST object for an expression
function parse_expression_p2(L)
  -- Read first operator argument (may be the only one)
  local subexpr = parse_expression_p1(L)
  while L.next.type == 'plus' or L.next.type == 'minus' do
    -- Read operator
    local optype = L.next.type
    L:read()
    -- Read second operator argument
    local subexpr2 = parse_expression_p1(L)
    if optype == 'plus' then
      subexpr = ast_expr_add(subexpr, subexpr2)
    elseif optype == 'minus' then
      subexpr = ast_expr_sub(subexpr, subexpr2)
    end
  end
  return subexpr
end

-- Tries to parse the rule: <expression-p3>
-- Returns the AST object for an expression
function parse_expression_p3(L)
  -- Read first operator argument (may be the only one)
  local subexpr = parse_expression_p2(L)
  while L.next.type == 'cmplt' or L.next.type == 'cmpgt' or L.next.type == 'cmpleq' or L.next.type == 'cmpgeq' do
    -- Read operator
    local optype = L.next.type
    L:read()
    -- Read second operator argument
    local subexpr2 = parse_expression_p2(L)
    if optype == 'cmplt' then
      subexpr = ast_expr_cmplt(subexpr, subexpr2)
    elseif optype == 'cmpgt' then
      subexpr = ast_expr_cmpgt(subexpr, subexpr2)
    elseif optype == 'cmpleq' then
      subexpr = ast_expr_cmpleq(subexpr, subexpr2)
    elseif optype == 'cmpgeq' then
      subexpr = ast_expr_cmpgeq(subexpr, subexpr2)
    end
  end
  return subexpr
end

-- Tries to parse the rule: <expression-p4>
-- Returns the AST object for an expression
function parse_expression_p4(L)
  -- Read first operator argument (may be the only one)
  local subexpr = parse_expression_p3(L)
  while L.next.type == 'cmpeq' or L.next.type == 'cmpneq' do
    -- Read operator
    local optype = L.next.type
    L:read()
    -- Read second operator argument
    local subexpr2 = parse_expression_p3(L)
    if optype == 'cmpeq' then
      subexpr = ast_expr_cmpeq(subexpr, subexpr2)
    elseif optype == 'cmpneq' then
      subexpr = ast_expr_cmpneq(subexpr, subexpr2)
    end
  end
  return subexpr
end

-- Tries to parse the rule: <expression-p5>
-- Returns the AST object for an expression
function parse_expression_p5(L)
  -- Read first operator argument (may be the only one)
  local subexpr = parse_expression_p4(L)
  while L.next.type == 'logand' do
    -- Read operator
    local optype = L.next.type
    L:read()
    -- Read second operator argument
    local subexpr2 = parse_expression_p4(L)
    if optype == 'logand' then
      subexpr = ast_expr_logand(subexpr, subexpr2)
    end
  end
  return subexpr
end

-- Tries to parse the rule: <expression-p6>
-- Returns the AST object for an expression
function parse_expression_p6(L)
  -- Read first operator argument (may be the only one)
  local subexpr = parse_expression_p5(L)
  while L.next.type == 'logor' do
    -- Read operator
    local optype = L.next.type
    L:read()
    -- Read second operator argument
    local subexpr2 = parse_expression_p5(L)
    if optype == 'logor' then
      subexpr = ast_expr_logor(subexpr, subexpr2)
    end
  end
  return subexpr
end

-- Tries to parse the rule: <expression>
parse_expression = parse_expression_p6

-- Expects to parse the rule: <block>
-- Returns the AST object for an expression
function expect_expression(L)
  local expr = parse_expression(L)
  if not expr then
    parse_abort_expected(L, 'expression')
  end
  return expr
end

local expect_statement
local parse_if_statement

-- Tries to parse the rule: <block>
-- Returns the AST object for a block statement
local function parse_block(L)
  if parse_token(L, 'lcurly') then
    local block = ast_stmt_block()
    while not parse_token(L, 'rcurly') do
      table.insert(block, expect_statement(L))
    end
    return block
  end
end

-- Expects to parse the rule: <block>
-- Returns the AST object for a block statement
local function expect_block(L)
  local block = parse_block(L)
  if not block then
    parse_abort_expected(L, 'block')
  end
  return block
end

-- Attempts to parse the rule: <if-body>
-- Returns the expression AST object and the block AST object separately
local function parse_if_body(L)
  local expr, block
  if parse_token(L, 'if') then
    expect_token(L, 'lparen')
    expr = expect_expression(L)
    expect_token(L, 'rparen')
    block = expect_block(L)
    return expr, block
  end
end

-- Tries to parse the rule: <else-body>
-- Returns the AST object for an if statement
local function parse_else_body(L)
  if parse_token(L, 'else') then
    local stmt = parse_if_statement(L)
    if stmt then return stmt end
    stmt = parse_block(L)
    if stmt then return stmt end
    -- Curly braces are not optional!
    parse_abort_expected(L, 'if', 'lcurly')
  end
end

-- Tries to parse the rule: <if-statement>
-- Returns the AST object for an if statement
parse_if_statement = function(L)
  local expr, if_stmt = parse_if_body(L)
  if expr then
    -- if statement parsed, try to read its else clause
    local else_stmt = parse_else_body(L)
    return ast_stmt_if(expr, if_stmt, else_stmt)
  end
end

-- Parses: [ <argument-list> ]
-- Returns the AST object for an argument list
-- Returns an empty list if no expressions could be read
local function parse_argument_list(L)
  local list = {}
  local expr = parse_expression(L)
  if expr then
    table.insert(list, expr)
    while parse_token(L, 'comma') do
      table.insert(list, expect_expression(L))
    end
  end
  return list
end

-- Parses: [ <argument-declaration-list> ]
-- Returns the AST object for a argument declaration list
-- Returns an empty list if no declarations could be read
local function parse_argument_declaration_list(L)
  local list = {}
  local name_path = parse_name_path(L)
  if name_path then
    local name = expect_name(L)
    table.insert(list, { type_name_path = name_path, name = name })
    while parse_token(L, 'comma') do
      local name_path = expect_name_path(L)
      local name = expect_name(L)
      table.insert(list, { type_name_path = name_path, name = name })
    end
  end
  return list
end

-- Expects to parse the rule: <statement>
-- Returns the AST object for a statement
expect_statement = function(L)
  if parse_token(L, 'return') then
    -- Easiest statement ever
    local stmt = ast_stmt_return(parse_expression(L))
    expect_token(L, 'semicolon')
    return stmt
  end
  local stmt = parse_if_statement(L)
  if stmt then return stmt end
  stmt = parse_block(L)
  if stmt then return stmt end
  local first_name = parse_name(L)
  if first_name then
    -- Reading a name could mean a variable declaration, or a variable assignment
    if parse_token(L, 'equals') then
      -- Assigning first_name to expr
      local expr = expect_expression(L)
      expect_token(L, 'semicolon')
      -- That's a variable assignment
      return ast_stmt_assign(first_name, expr)
    end
    -- Read remainder of path, if applicable (first name already known)
    name_path = parse_name_path_rest(L, first_name)
    -- Try to read a name
    local name = parse_name(L)
    if name then
      -- name_path is a local variable declaration's type
      expect_token(L, 'semicolon')
      -- That's the declaration, me boy
      return ast_stmt_local_declaration(name_path, name)
    end
    -- Try to read an lparen
    if parse_token(L, 'lparen') then
      -- Read function call arg_list
      local arg_list = parse_argument_list(L)
      expect_token(L, 'rparen')
      expect_token(L, 'semicolon')
      return ast_stmt_function_call(name_path, arg_list)
    end
    parse_abort_expected(L, 'equals', 'colon', 'name', 'lparen')
  end
  parse_abort_expected(L, 'statement')
end

-- Tries to parse the rule: <function-declaration>
-- Returns the AST object for a function declaration
local function parse_function_declaration(L)
  if parse_token(L, 'function') then
    local name = expect_name(L)
    expect_token(L, 'lparen')
    local arguments = parse_argument_declaration_list(L)
    expect_token(L, 'rparen')
    local block = parse_block(L)
    return ast_function_declaration(name, arguments, block)
  end
end

-- Tries to parse the rule: <member-declaration>
-- Returns the AST object for a member declaration
local function parse_member_declaration(L)
  local type_name_path = parse_name_path(L)
  if type_name_path then
    local name = expect_name(L)
    expect_token(L, 'semicolon')
    return ast_member_declaration(type_name_path, name)
  end
end

-- Expects to parse the rule: <module-body-declaration>
-- Returns the appropriate AST object for the declaration
local function expect_module_body_declaration(L)
  local decl = parse_function_declaration(L)
  if decl then return decl end
  decl = parse_member_declaration(L)
  if decl then return decl end
  parse_abort_expected(L, 'member/function declaration');
end

-- Tries to parse the rule: <module-declaration>
-- Returns the AST object for a module declaration
local function parse_module_declaration(L)
  local name_path 
  local declarations = {}
  if parse_token(L, 'module') then
    name_path = expect_name_path(L)
    expect_token(L, 'lcurly')
    -- Read declarations until an rcurly
    while not parse_token(L, 'rcurly') do
      table.insert(declarations, expect_module_body_declaration(L))
    end
    return ast_module_declaration(name_path, declarations)
  end
end

-- Expects to parse the rule: <file-scope-declaration>
-- Returns the appropriate AST object for the declaration
local function expect_file_scope_declaration(L)
  local decl = parse_struct_declaration(L)
  if decl then return decl end
  decl = parse_module_declaration(L)
  if decl then return decl end
  parse_abort_expected(L, 'file-scope declaration');
end

-- Parses a file
-- Returns the AST object for a translation unit
local function parse_file(file_in)
  local L = Lexer(file_in)
  local file_declarations = {}
  while not parse_token(L, 'eof') do
    table.insert(file_declarations, expect_file_scope_declaration(L))
  end
  L:close()
  return file_declarations
end

--------------------------------------------------------------------------------
-- Intermediate Representation
--------------------------------------------------------------------------------

local function ir_mov(reg_z, reg_x)
  return { type = 'mov', register_z = reg_z, register_x = reg_x }
end

local function ir_neg(reg_z, reg_x)
  return { type = 'neg', register_z = reg_z, register_x = reg_x }
end
local function ir_bnot(reg_z, reg_x)
  return { type = 'bnot', register_z = reg_z, register_x = reg_x }
end
local function ir_lnot(reg_z, reg_x)
  return { type = 'lnot', register_z = reg_z, register_x = reg_x }
end

local function ir_add(reg_z, reg_x, reg_y)
  return { type = 'add', register_z = reg_z, register_x = reg_x, register_y = reg_y }
end
local function ir_sub(reg_z, reg_x, reg_y)
  return { type = 'sub', register_z = reg_z, register_x = reg_x, register_y = reg_y }
end
local function ir_mul(reg_z, reg_x, reg_y)
  return { type = 'mul', register_z = reg_z, register_x = reg_x, register_y = reg_y }
end
local function ir_div(reg_z, reg_x, reg_y)
  return { type = 'div', register_z = reg_z, register_x = reg_x, register_y = reg_y }
end

local function ir_eq(reg_z, reg_x, reg_y)
  return { type = 'eq', register_z = reg_z, register_x = reg_x, register_y = reg_y }
end
local function ir_neq(reg_z, reg_x, reg_y)
  return { type = 'neq', register_z = reg_z, register_x = reg_x, register_y = reg_y }
end
local function ir_lt(reg_z, reg_x, reg_y)
  return { type = 'lt', register_z = reg_z, register_x = reg_x, register_y = reg_y }
end
local function ir_gt(reg_z, reg_x, reg_y)
  return { type = 'gt', register_z = reg_z, register_x = reg_x, register_y = reg_y }
end
local function ir_leq(reg_z, reg_x, reg_y)
  return { type = 'leq', register_z = reg_z, register_x = reg_x, register_y = reg_y }
end
local function ir_geq(reg_z, reg_x, reg_y)
  return { type = 'geq', register_z = reg_z, register_x = reg_x, register_y = reg_y }
end

local function ir_salloc(size)
  return { type = 'salloc', size = size }
end
local function ir_sfree(size)
  return { type = 'sfree', size = size }
end

local function ir_call(name)
  return { type = 'call', name = name }
end
local function ir_ret()
  return { type = 'ret' }
end

-- Defines a jump label
local function ir_label(name)
  return { type = 'label', name = name }
end
-- Unconditional jump
local function ir_jmp(label_name)
  return { type = 'jmp', label_name = label_name }
end
-- Jump if equal
local function ir_jeq(label_name, reg_x, reg_y)
  return { type = 'jeq', label_name = label_name, register_x = reg_x, register_y = reg_y }
end
-- Jump if not equal
local function ir_jneq(label_name, reg_x, reg_y)
  return { type = 'jneq', label_name = label_name, register_x = reg_x, register_y = reg_y }
end
-- Jump if zero
local function ir_jz(label_name, reg)
  return { type = 'jz', label_name = label_name, register = reg }
end
-- Jump if nonzero
local function ir_jnz(label_name, reg)
  return { type = 'jnz', label_name = label_name, register = reg }
end
-- Jump if less than
local function ir_jlt(label_name, reg_x, reg_y)
  return { type = 'jlt', label_name = label_name, register_x = reg_x, register_y = reg_y }
end
-- Jump if greater than
local function ir_jgt(label_name, reg_x, reg_y)
  return { type = 'jgt', label_name = label_name, register_x = reg_x, register_y = reg_y }
end
-- Jump if less than or equal
local function ir_jleq(label_name, reg_x, reg_y)
  return { type = 'jleq', label_name = label_name, register_x = reg_x, register_y = reg_y }
end
-- Jump if greater than or equal
local function ir_jgeq(label_name, reg_x, reg_y)
  return { type = 'jgeq', label_name = label_name, register_x = reg_x, register_y = reg_y }
end

--------------------------------------------------------------------------------
-- Compilation
--------------------------------------------------------------------------------

local function dupscope(scope)
  local new_scope = { }
  -- Inerit access to all of this scope's local variables
  for k,v in pairs(scope) do
    new_scope[k] = scope[k]
  end
  return new_scope
end

local function pushtemp(ctx)
  local idx = ctx.temp_index
  ctx.temp_index = ctx.temp_index + 1
  if ctx.temp_index > ctx.temp_index_max then
    ctx.temp_index_max = ctx.temp_index
  end
  return 'r'..idx
end
local function poptemp(ctx)
  ctx.temp_index = ctx.temp_index - 1
end
local function cleartemps(ctx)
  ctx.temp_index = 0
end

local function findlocal(ctx, name)
  local reg = ctx.local_scope[name]
  if reg then
    return reg
  else
    error('`'..name..'` was not found in this scope.')
  end
end

local function newlabel(ctx)
  local idx = ctx.label_index
  ctx.label_index = ctx.label_index + 1
  return 'l'..idx
end

local function ir_emit(ctx, ir_stmt)
  table.insert(ctx.statements, ir_stmt)
end

local ir_emit_expression

-- IR (e)mit (e)xpression (t)able
local ir_eet = { }

function ir_eet.integer(ctx, expr)
  local reg = pushtemp(ctx)
  ir_emit(ctx, ir_mov(reg, expr.value))
  return reg
end

function ir_eet.negate(ctx, expr)
  local reg = ir_emit_expression(ctx, expr.expression)
  ir_emit(ctx, ir_neg(reg, reg))
  return reg
end

function ir_eet.binnot(ctx, expr)
  local reg = ir_emit_expression(ctx, expr.expression)
  ir_emit(ctx, ir_bnot(reg, reg))
  return reg
end

function ir_eet.lognot(ctx, expr)
  local reg = ir_emit_expression(ctx, expr.expression)
  ir_emit(ctx, ir_lnot(reg, reg))
  return reg
end

function ir_eet.add(ctx, expr)
  -- Emit subexpressions
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  -- Add this instruction to the list
  ir_emit(ctx, ir_add(reg_a, reg_a, reg_b))
  -- Free reg_b, it will be at the top of the temp stack
  poptemp(ctx)
  -- Return register of result
  return reg_a
end

function ir_eet.sub(ctx, expr)
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  ir_emit(ctx, ir_sub(reg_a, reg_a, reg_b))
  poptemp(ctx)
  return reg_a
end

function ir_eet.mul(ctx, expr)
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  ir_emit(ctx, ir_mul(reg_a, reg_a, reg_b))
  poptemp(ctx)
  return reg_a
end

function ir_eet.div(ctx, expr)
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  ir_emit(ctx, ir_div(reg_a, reg_a, reg_b))
  poptemp(ctx)
  return reg_a
end

function ir_eet.cmpeq(ctx, expr)
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  ir_emit(ctx, ir_eq(reg_a, reg_a, reg_b))
  poptemp(ctx)
  return reg_a
end

function ir_eet.cmpneq(ctx, expr)
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  ir_emit(ctx, ir_neq(reg_a, reg_a, reg_b))
  poptemp(ctx)
  return reg_a
end

function ir_eet.cmplt(ctx, expr)
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  ir_emit(ctx, ir_lt(reg_a, reg_a, reg_b))
  poptemp(ctx)
  return reg_a
end

function ir_eet.cmpgt(ctx, expr)
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  ir_emit(ctx, ir_gt(reg_a, reg_a, reg_b))
  poptemp(ctx)
  return reg_a
end

function ir_eet.cmpleq(ctx, expr)
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  ir_emit(ctx, ir_leq(reg_a, reg_a, reg_b))
  poptemp(ctx)
  return reg_a
end

function ir_eet.cmpgeq(ctx, expr)
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  ir_emit(ctx, ir_geq(reg_a, reg_a, reg_b))
  poptemp(ctx)
  return reg_a
end

function ir_eet.logand(ctx, expr)
  local lab1 = newlabel(ctx)
  local lab2 = newlabel(ctx)
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  -- If nonzero, jump to the evaluation of the next expression
  -- Otherwise, the result is zero, and reg_a already contains zero, so jump to end
  ir_emit(ctx, ir_jnz(lab1, reg_a));
  ir_emit(ctx, ir_jmp(lab2));
  ir_emit(ctx, ir_label(lab1))
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  -- Set reg_a to zero iff reg_b is zero
  ir_emit(ctx, ir_neq(reg_a, reg_b, 0))
  ir_emit(ctx, ir_label(lab2))
  poptemp(ctx)
  return reg_a
end

function ir_eet.logor(ctx, expr)
  local lab1 = newlabel(ctx)
  local lab2 = newlabel(ctx)
  local reg_a = ir_emit_expression(ctx, expr.expression_a)
  -- If zero, jump to the evaluation of the next expression
  -- Otherwise, set result to one, and jump to end
  ir_emit(ctx, ir_jz(lab1, reg_a));
  ir_emit(ctx, ir_mov(reg_a, 1));
  ir_emit(ctx, ir_jmp(lab2));
  ir_emit(ctx, ir_label(lab1))
  local reg_b = ir_emit_expression(ctx, expr.expression_b)
  -- Set reg_a to zero iff reg_b is zero
  ir_emit(ctx, ir_neq(reg_a, reg_b, 0))
  ir_emit(ctx, ir_label(lab2))
  poptemp(ctx)
  return reg_a
end

function ir_eet.variable(ctx, expr)
  local reg = pushtemp(ctx)
  ir_emit(ctx, ir_mov(reg, findlocal(ctx, expr.name)))
  return reg
end

ir_emit_expression = function(ctx, expr)
  local h = ir_eet[expr.type]
  if h then
    return h(ctx, expr)
  else
    io.write('Unknown expression type `'..expr.type..'`\n')
    os.exit(4)
  end
end

local ir_emit_statement

-- IR (e)mit (s)tatement (t)able
local ir_est = {}

ir_est['if'] = function(ctx, ast_stmt)
  if ast_stmt.else_statement then
    local lab1 = newlabel(ctx)
    local lab2 = newlabel(ctx)
    local reg_exp = ir_emit_expression(ctx, ast_stmt.expression)
    ir_emit(ctx, ir_jz(lab1, reg_exp))
    ir_emit_statement(ctx, ast_stmt.if_statement)
    ir_emit(ctx, ir_jmp(lab2))
    ir_emit(ctx, ir_label(lab1))
    ir_emit_statement(ctx, ast_stmt.else_statement)
    ir_emit(ctx, ir_label(lab2))
  else
    local lab1 = newlabel(ctx)
    local reg_exp = ir_emit_expression(ctx, ast_stmt.expression)
    ir_emit(ctx, ir_jz(lab1, reg_exp))
    ir_emit_statement(ctx, ast_stmt.if_statement)
    ir_emit(ctx, ir_label(lab1))
  end
end

ir_est['local'] = function(ctx, ast_stmt)
  io.write('local `'..ast_stmt.name..'` is at index '..ctx.local_index..'\n')
  ctx.local_scope[ast_stmt.name] = 's'..ctx.local_index
  ctx.local_index = ctx.local_index + 1
end

ir_est['return'] = function(ctx, ast_stmt)
  local expr = ast_stmt.expression
  if expr then
    local reg = ir_emit_expression(ctx, expr)
  else
    local reg = pushtemp(ctx)
    ir_emit(ctx, ir_mov(reg, 0))
  end
  ir_emit(ctx, ir_ret())
end

function ir_est.assign(ctx, ast_stmt)
  local reg = ir_emit_expression(ctx, ast_stmt.expression)
  ir_emit(ctx, ir_mov(findlocal(ctx, ast_stmt.name), reg))
end

function ir_est.block(ctx, ast_stmt)
  -- Calculate total stack space required by this block
  local stack_size = 0
  for i,ast_substmt in ipairs(ast_stmt) do
    if ast_substmt.type == 'local' then
      stack_size = stack_size + 1
    end
  end

  io.write('this block will use '..stack_size..' words of stack space\n')

  local local_index_block_prev
  local local_index_prev
  local local_scope_prev

  if stack_size ~= 0 then
    ir_emit(ctx, ir_salloc(stack_size))

    local_index_prev = ctx.local_index
    local_scope_prev = ctx.local_scope

    ctx.local_scope = dupscope(ctx.local_scope)
  end

  for i,ast_substmt in ipairs(ast_stmt) do
    ir_emit_statement(ctx, ast_substmt)
  end

  -- If we're a top level block, don't try to free the stack. The stack is assumed to be restored
  -- when the function returns.
  if stack_size ~= 0 then
    ir_emit(ctx, ir_sfree(stack_size))

    ctx.local_index = local_index_prev
    ctx.local_scope = local_scope_prev
  end
end

function ir_est.call(ctx, ast_stmt)
  -- HACK ALERT: Really punting on this one
  local name = 'my_module$'..table.concat(ast_stmt.name_path, '$')
  -- Get the stack ready for this function call
  ir_emit(ctx, ir_salloc(#ast_stmt.argument_list))
  -- Evaluate each expression and store
  local arglist = ast_stmt.argument_list
  for k=#arglist,1,-1 do
    local ast_expr = arglist[k]
    local reg = ir_emit_expression(ctx, ast_expr)
    local arg_reg = 's'..(ctx.local_index + #arglist - k)
    ir_emit(ctx, ir_mov(arg_reg, reg))
  end
  ir_emit(ctx, ir_call(name))
  ir_emit(ctx, ir_sfree(#ast_stmt.argument_list))
end

ir_emit_statement = function(ctx, ast_stmt)
  -- All temporary registers are free game at the beginning of a statement
  cleartemps(ctx)
  local h = ir_est[ast_stmt.type]
  if h then
    h(ctx, ast_stmt)
  else
    error('Unknown AST statement type `'..ast_stmt.type..'`')
  end
end

local function ir_subroutine(ast_module_name_path, ast_func)
  local arguments = { 'int', 'int' }
  local returns = { 'int' }
  local statements = { }

  -- Populate initial scope with argument registers
  local local_scope = { }
  for k,ast_arg_decl in ipairs(ast_func.arguments) do
    local_scope[ast_arg_decl.name] = 'i'..(k-1)
  end

  ctx = {
    local_scope = local_scope,
    statements = statements,
    local_index = 0,
    -- Counter / high water mark for the temp stack
    temp_index = 0,
    temp_index_max = 0,
    -- Counter for unique label generation
    label_index = 0,
  }

  assert(ast_func.block.type == 'block')
  ir_est.block(ctx, ast_func.block, true)

  return {
    type = 'subroutine',
    name = table.concat(ast_module_name_path, '$')..'$'..ast_func.name,
    arguments = arguments,
    returns = returns,
    statements = statements,
    meta = {
      temp_count = ctx.temp_index_max,
    },
  }
end

local function compile_ir(ast)
  local ir = {}
  ir.subroutines = {}
  for i,ast_fdecl in ipairs(ast) do
    if ast_fdecl.type == 'module' then
      local ast_module = ast_fdecl
      for i,mdecl in ipairs(ast_module.declarations) do
        if mdecl.type == 'function' then
          local ast_func = mdecl
          table.insert(ir.subroutines, ir_subroutine(ast_module.name_path, ast_func))
        end
      end
    end
  end
  return ir
end

-- IR (d)ump (s)tatement (t)able
local ir_dst = {}

function ir_dst.salloc(stmt)
  io.write('  salloc '..stmt.size..'\n')
end
function ir_dst.sfree(stmt)
  io.write('  sfree '..stmt.size..'\n')
end

function ir_dst.mov(stmt)
  io.write('  '..stmt.register_z..' := '..stmt.register_x..'\n')
end

function ir_dst.neg(stmt)
  io.write('  '..stmt.register_z..' := -'..stmt.register_x..'\n')
end
function ir_dst.bnot(stmt)
  io.write('  '..stmt.register_z..' := ~'..stmt.register_x..'\n')
end
function ir_dst.lnot(stmt)
  io.write('  '..stmt.register_z..' := !'..stmt.register_x..'\n')
end

function ir_dst.add(stmt)
  io.write('  '..stmt.register_z..' := '..stmt.register_x..' + '..stmt.register_y..'\n')
end
function ir_dst.sub(stmt)
  io.write('  '..stmt.register_z..' := '..stmt.register_x..' - '..stmt.register_y..'\n')
end
function ir_dst.mul(stmt)
  io.write('  '..stmt.register_z..' := '..stmt.register_x..' * '..stmt.register_y..'\n')
end
function ir_dst.div(stmt)
  io.write('  '..stmt.register_z..' := '..stmt.register_x..' / '..stmt.register_y..'\n')
end

function ir_dst.eq(stmt)
  io.write('  '..stmt.register_z..' := '..stmt.register_x..' == '..stmt.register_y..'\n')
end
function ir_dst.neq(stmt)
  io.write('  '..stmt.register_z..' := '..stmt.register_x..' != '..stmt.register_y..'\n')
end
function ir_dst.lt(stmt)
  io.write('  '..stmt.register_z..' := '..stmt.register_x..' < '..stmt.register_y..'\n')
end
function ir_dst.gt(stmt)
  io.write('  '..stmt.register_z..' := '..stmt.register_x..' > '..stmt.register_y..'\n')
end
function ir_dst.leq(stmt)
  io.write('  '..stmt.register_z..' := '..stmt.register_x..' <= '..stmt.register_y..'\n')
end
function ir_dst.geq(stmt)
  io.write('  '..stmt.register_z..' := '..stmt.register_x..' >= '..stmt.register_y..'\n')
end

function ir_dst.pusharg(stmt)
  io.write('  pusharg '..stmt.register..'\n')
end
function ir_dst.poparg(stmt)
  io.write('  poparg '..stmt.register..'\n')
end
function ir_dst.call(stmt)
  io.write('  call '..stmt.name..'\n')
end
function ir_dst.ret(stmt)
  io.write('  ret\n')
end

function ir_dst.label(stmt)
  io.write(stmt.name..':\n')
end
function ir_dst.jmp(stmt)
  io.write('  goto '..stmt.label_name..'\n')
end
function ir_dst.jz(stmt)
  io.write('  if !'..stmt.register..' goto '..stmt.label_name..'\n')
end
function ir_dst.jnz(stmt)
  io.write('  if '..stmt.register..' goto '..stmt.label_name..'\n')
end
function ir_dst.jeq(stmt)
  io.write('  if '..stmt.register_x..' == '..stmt.register_y..' goto '..stmt.label_name..'\n')
end
function ir_dst.jneq(stmt)
  io.write('  if '..stmt.register_x..' != '..stmt.register_y..' goto '..stmt.label_name..'\n')
end
function ir_dst.jlt(stmt)
  io.write('  if '..stmt.register_x..' < '..stmt.register_y..' goto '..stmt.label_name..'\n')
end
function ir_dst.jgt(stmt)
  io.write('  if '..stmt.register_x..' > '..stmt.register_y..' goto '..stmt.label_name..'\n')
end
function ir_dst.jleq(stmt)
  io.write('  if '..stmt.register_x..' <= '..stmt.register_y..' goto '..stmt.label_name..'\n')
end
function ir_dst.jgeq(stmt)
  io.write('  if '..stmt.register_x..' >= '..stmt.register_y..' goto '..stmt.label_name..'\n')
end

function ir_dump_statement(stmt)
  local h = ir_dst[stmt.type]
  if h then
    h(stmt)
  else
    error('Unknown IR statement type `'..stmt.type..'`')
  end
end

local function ir_dump_subroutine(subr)
  io.write('  ; temp_count: '..subr.meta.temp_count..'\n')
  io.write('sub '..subr.name..' (')
  for i,arg_type in ipairs(subr.arguments) do
    io.write(arg_type)
    if i ~= #subr.arguments then
      io.write(',')
    end
  end
  io.write(' : ')
  for i,arg_type in ipairs(subr.returns) do
    io.write(arg_type)
    if i ~= #subr.returns then
      io.write(',')
    end
  end
  io.write(')\n')
  for i,stmt in ipairs(subr.statements) do
    --pprint(stmt)
    ir_dump_statement(stmt)
  end
  io.write('\n')
end

local function ir_dump(ir)
  for i,subr in ipairs(ir.subroutines) do
    ir_dump_subroutine(subr)
  end
end

--------------------------------------------------------------------------------
-- Code Generation
--------------------------------------------------------------------------------

local function emit(ctx, instr)
  ctx.outfile:write('\t'..instr..'\n')
end

local function emit_noindent(ctx, instr)
  ctx.outfile:write(instr..'\n')
end

local function emit_label(ctx, label)
  ctx.outfile:write(label..':\n')
end

local function emit_line(ctx)
  ctx.outfile:write('\n')
end

local function emit_prologue(ctx)
  emit(ctx, 'push %rbp')
  emit(ctx, 'mov  %rsp, %rbp')
end

local function emit_epilogue(ctx)
  emit(ctx, 'mov  %rbp, %rsp')
  emit(ctx, 'pop  %rbp')
  emit(ctx, 'ret')
end

-- (o)perand (t)emporary (r)egister (t)able
local otrt = {
  '%rax',
  '%rcx',
  '%rdx',
  '%r8',
  '%r9',
  '%r10',
  '%r11',
}

local function operand(ctx, name)
  local typestr = string.sub(name, 1, 1)
  if typestr == 'r' then
    -- Temporary access
    local index = string.match(name, 'r(%d+)')
    if not index then
      error('Invalid IR temporary register `'..name..'`')
    end
    index = tonumber(index)
    if index > ctx.temp_count then
      error('Invalid IR temp register `'..name..'` exceeds maximum of `'..ctx.temp_count..'`')
    end
    local op = otrt[index+1]
    if op then
      return op, 'register'
    else
      error('TODO: Implement spilling')
      --return tostring(-8*(index-1))..'(%rbp)', 'memory'
    end
  elseif typestr == 's' then
    -- Stack access
    local index = string.match(name, 's(%d+)')
    if not index then
      error('Invalid IR stack register `'..name..'`')
    end
    index = tonumber(index)
    return tostring(-8*(index+1))..'(%rbp)', 'memory'
  elseif typestr == 'i' then
    -- Stack access
    local index = string.match(name, 'i(%d+)')
    if not index then
      error('Invalid IR input/output register `'..name..'`')
    end
    index = tonumber(index)
    return tostring(8*(index+2))..'(%rbp)', 'memory'
  else
    local integer = tonumber(name)
    if not integer then
      error('Failed to generate operand for `'..name..'`')
    end
    return '$'..integer, 'literal'
  end
end

-- These registers must be preserved:
--   %rbx
--   %rbp
--   %r12
--   %r13
--   %r14
--   %r15
-- These registers are fair game
local rbft = {
  ['%rax'] = '%al',
  ['%rcx'] = '%cl',
  ['%rdx'] = '%dl',
  ['%r8'] = '%r8b',
  ['%r9'] = '%r9b',
  ['%r10'] = '%r10b',
  ['%r11'] = '%r11b',
}

local function reg_byte_form(op, type)
  if type == 'register' then
    local r = rbft[op]
    if not r then
      error('Register byte form for `'..op..'` not yet set')
    end
    return r
  end
  -- hmmm, since we're LSB first this should still work for memory addresses
  return op
end

local function emit_mov(ctx, op_x, type_x, op_z, type_z)
  -- Destination can't be a literal, that doesn't make any damn sense
  if type_z == 'literal' then error('Invalid instruction') end
  -- Optimize out useless moves
  if op_x == op_z then return end
  -- Move if possible
  if type_x == 'register' or type_z == 'register' then
    -- If either is a register, only one memory reference is possible
    emit(ctx, 'mov  '..op_x..', '..op_z)
  else
    emit(ctx, 'push %rax')
    emit(ctx, 'mov  '..op_x..', %rax')
    emit(ctx, 'mov  %rax, '..op_z)
    emit(ctx, 'pop  %rax')
  end
end

local function emit_binary_arith_op(ctx, instr, ir_stmt)
  local op_x, type_x = operand(ctx, ir_stmt.register_x)
  local op_y, type_y = operand(ctx, ir_stmt.register_y)
  local op_z, type_z = operand(ctx, ir_stmt.register_z)
  -- Destination can't be a literal, that doesn't make any damn sense
  if type_z == 'literal' then error('Invalid instruction') end
  if type_z == 'register' then
    -- op_z is a register, so only a single memory reference is possible here
    if op_x ~= op_z then
      emit(ctx, 'mov  '..op_x..', '..op_z)
    end
    emit(ctx, instr..' '..op_y..', '..op_z)
  else
    -- Have to push something otherwise, and destination must be a register
    emit(ctx, 'push %rax')
    emit(ctx, 'mov  '..op_x..', %rax')
    emit(ctx, instr..' '..op_y..', %rax')
    emit(ctx, 'mov  %rax, '..op_z)
    emit(ctx, 'pop  %rax')
  end
end

local function emit_comparison(ctx, set_instr, ir_stmt)
  local op_x, type_x = operand(ctx, ir_stmt.register_x)
  local op_y, type_y = operand(ctx, ir_stmt.register_y)
  local op_z, type_z = operand(ctx, ir_stmt.register_z)
  -- Destination can't be a literal, that doesn't make any damn sense
  if type_z == 'literal' then error('Invalid instruction') end
  if type_x == 'register' or type_z == 'register' then
    -- Either is a register, so only a single memory reference is possible here
    emit(ctx, 'cmp  '..op_x..', '..op_y)
  else
    -- Have to push something otherwise
    emit(ctx, 'push %rax')
    emit(ctx, 'mov  '..op_x..', %rax')
    emit(ctx, 'cmp  %rax, '..op_y)
    emit(ctx, 'pop  %rax')
  end
  -- Clear result and set based on condition
  emit(ctx, 'mov  $0, '..op_z)
  emit(ctx, set_instr..' '..reg_byte_form(op_z, type_z))
end

local function emit_jump_comparison(ctx, jump_instr, ir_stmt)
  local op_x, type_x = operand(ctx, ir_stmt.register_x)
  local op_y, type_y = operand(ctx, ir_stmt.register_y)
  -- Destination can't be a literal, that doesn't make any damn sense
  if type_x == 'literal' and type_y == 'literal' then error('Invalid instruction') end
  if type_x == 'register' or type_z == 'register' then
    -- Either is a register, so only a single memory reference is possible here
    emit(ctx, 'cmp  '..op_x..', '..op_y)
  else
    -- Have to push something otherwise
    emit(ctx, 'push %rax')
    emit(ctx, 'mov  '..op_x..', %rax')
    emit(ctx, 'cmp  %rax, '..op_y)
    emit(ctx, 'pop  %rax')
  end
  -- Jump based on condition
  emit(ctx, jump_instr..' '..convert_label(ctx, ir_stmt.label_name))
end

local function convert_label(ctx, ir_name)
  return '_s'..ctx.subroutine_id..ir_name
end

-- (e)mit (s)tatement (t)able
local est = {}

function est.mov(ctx, ir_stmt)
  local op_x, type_x = operand(ctx, ir_stmt.register_x)
  local op_z, type_z = operand(ctx, ir_stmt.register_z)
  emit_mov(ctx, op_x, type_x, op_z, type_z)
end

function est.neg(ctx, ir_stmt)
  local op_x, type_x = operand(ctx, ir_stmt.register_x)
  local op_z, type_z = operand(ctx, ir_stmt.register_z)
  emit_mov(ctx, op_x, type_x, op_z, type_z)
  emit(ctx, 'negq '..op_z)
end
function est.bnot(ctx, ir_stmt)
  local op_x, type_x = operand(ctx, ir_stmt.register_x)
  local op_z, type_z = operand(ctx, ir_stmt.register_z)
  emit_mov(ctx, op_x, type_x, op_z, type_z)
  emit(ctx, 'notq '..op_z)
end
function est.lnot(ctx, ir_stmt)
  local op_x, type_x = operand(ctx, ir_stmt.register_x)
  local op_z, type_z = operand(ctx, ir_stmt.register_z)
  emit_mov(ctx, op_x, type_x, op_z, type_z)
  emit(ctx, 'cmp  $0, '..op_z)
  emit(ctx, 'mov  $0, '..op_z)
  emit(ctx, 'sete '..reg_byte_form(op_z, type_z))
end

function est.add(ctx, ir_stmt)
  emit_binary_arith_op(ctx, 'addq', ir_stmt)
end
function est.sub(ctx, ir_stmt)
  emit_binary_arith_op(ctx, 'subq', ir_stmt)
end
function est.mul(ctx, ir_stmt)
  emit_binary_arith_op(ctx, 'imul', ir_stmt)
end
function est.div(ctx, ir_stmt)
  -- This implementation is most efficient if op_x and op_z are both r0; hence, if division is the
  -- first element of its statement.
  -- Though, it's pretty marginal compared to how many cycles integer division itself takes.
  local op_x, type_x = operand(ctx, ir_stmt.register_x)
  local op_y, type_y = operand(ctx, ir_stmt.register_y)
  local op_z, type_z = operand(ctx, ir_stmt.register_z)
  if type_z == 'literal' then error('Invalid instruction') end
  -- Backup %rax,%rdx if applicable
  -- This backup flow control has an interesting pattern. We only push registers that would be
  -- clobbered, and aren't the destination.
  if op_z ~= '%rax' then
    emit(ctx, 'push %rax')
  end
  if op_z ~= '%rdx' then
    emit(ctx, 'push %rdx')
  end
  -- Place our dividend in %rax
  if op_x ~= '%rax' then
    emit(ctx, 'mov  '..op_x..', %rax')
  end
  -- Sign extend %rax into %rdx.
  -- This clobbers %rdx, and kills the crab.
  emit(ctx, 'cqto')
  -- Divide [%rdx:%rax] by the divisor (op_y)
  emit(ctx, 'idivq '..op_y)
  -- Move the quotient into our destination (op_z)
  if op_z ~= '%rax' then
    emit(ctx, 'mov  %rax, '..op_z)
  end
  -- Restore %rax,%rdx if applicable
  if op_z ~= '%rdx' then
    emit(ctx, 'pop  %rdx')
  end
  if op_z ~= '%rax' then
    emit(ctx, 'pop  %rax')
  end
end

function est.eq(ctx, ir_stmt)
  emit_comparison(ctx, 'sete', ir_stmt)
end
function est.neq(ctx, ir_stmt)
  emit_comparison(ctx, 'setne', ir_stmt)
end
function est.lt(ctx, ir_stmt)
  emit_comparison(ctx, 'setl', ir_stmt)
end
function est.gt(ctx, ir_stmt)
  emit_comparison(ctx, 'setg', ir_stmt)
end
function est.leq(ctx, ir_stmt)
  emit_comparison(ctx, 'setle', ir_stmt)
end
function est.geq(ctx, ir_stmt)
  emit_comparison(ctx, 'setge', ir_stmt)
end

function est.salloc(ctx, ir_stmt)
  -- Allocate by subtracting from %rsp
  emit(ctx, 'sub  $'..(ir_stmt.size*8)..', %rsp')
end
function est.sfree(ctx, ir_stmt)
  -- Deallocate by adding to %rsp
  emit(ctx, 'add  $'..(ir_stmt.size*8)..', %rsp')
end

function est.call(ctx, ir_stmt)
  emit(ctx, 'call '..ir_stmt.name)
end
function est.ret(ctx, ir_stmt)
  emit_epilogue(ctx)
end

function est.label(ctx, ir_stmt)
  emit_label(ctx, convert_label(ctx, ir_stmt.name))
end
function est.jmp(ctx, ir_stmt)
  emit(ctx, 'jmp '..convert_label(ctx, ir_stmt.label_name))
end
function est.jz(ctx, ir_stmt)
  local op_x, type_x = operand(ctx, ir_stmt.register)
  if type_x == 'literal' then error('Invalid instruction') end
  emit(ctx, 'cmp $0, '..op_x)
  emit(ctx, 'je '..convert_label(ctx, ir_stmt.label_name))
end
function est.jnz(ctx, ir_stmt)
  local op_x, type_x = operand(ctx, ir_stmt.register)
  if type_x == 'literal' then error('Invalid instruction') end
  emit(ctx, 'cmp $0, '..op_x)
  emit(ctx, 'jne '..convert_label(ctx, ir_stmt.label_name))
end
function est.jeq(ctx, ir_stmt)
  emit_jump_comparison(ctx, 'je', ir_stmt)
end
function est.jneq(ctx, ir_stmt)
  emit_jump_comparison(ctx, 'jne', ir_stmt)
end
function est.jlt(ctx, ir_stmt)
  emit_jump_comparison(ctx, 'jl', ir_stmt)
end
function est.jgt(ctx, ir_stmt)
  emit_jump_comparison(ctx, 'jg', ir_stmt)
end
function est.jleq(ctx, ir_stmt)
  emit_jump_comparison(ctx, 'jle', ir_stmt)
end
function est.jgeq(ctx, ir_stmt)
  emit_jump_comparison(ctx, 'jge', ir_stmt)
end

function emit_statement(ctx, ir_stmt)
  local h = est[ir_stmt.type]
  if h then
    h(ctx, ir_stmt)
  else
    error('Unknown IR statement type `'..ir_stmt.type..'`')
  end
end

local function emit_subroutine(ctx, ir_subr)
  -- Emit header
  emit(ctx, '.globl '..ir_subr.name)
  emit(ctx, '.type '..ir_subr.name..', @function')
  emit_label(ctx, ir_subr.name)
  emit_prologue(ctx)
  ctx.temp_count = math.max(ir_subr.meta.temp_count, 2)
  -- Emit statements
  for i,ir_stmt in ipairs(ir_subr.statements) do
    emit_statement(ctx, ir_stmt)
  end
  -- Emit default footer if the subroutine didn't already include one
  local last_ir_stmt = ir_subr.statements[#ir_subr.statements]
  if last_ir_stmt.type ~= 'ret' then
    emit(ctx, 'mov $0, %rax')
    emit_epilogue(ctx)
  end
end

local function generate(ir, outfile)
  local ctx = {
    outfile = outfile,
    subroutine_id = 0,
    temp_count = nil,
  }

  emit(ctx, '.text')
  emit_line(ctx)

  for i,ir_subr in ipairs(ir.subroutines) do
    emit_subroutine(ctx, ir_subr)
    emit_line(ctx)
    ctx.subroutine_id = ctx.subroutine_id + 1
  end

  emit(ctx, '.globl main')
  emit(ctx, '.type main, @function')
  emit_label(ctx, 'main')
  emit(ctx, 'call my_module$func1')
  emit(ctx, 'ret')
  emit_line(ctx)
end

--------------------------------------------------------------------------------

io.output(io.stderr)

local function exit_usage()
  io.write('Usage: '..arg[0]..' <infile> [outfile]\n')
  os.exit(1)
end

local function exit_error(errstr)
  io.write(arg[0]..': Error: '..errstr..'\n')
  os.exit(1)
end

local filename_in = arg[1]
if not filename_in then exit_usage() end

local filename_out = arg[2]

if filename_in == filename_out then
  exit_error('infile must not match outfile')
end

local file_in = io.open(filename_in)
if not file_in then
  io.write('Failed to open `'..filename_in..'` for reading\n')
  os.exit(2)
end

local file_out
if filename_out then
  file_out = io.open(filename_out, "w")
  if not file_out then
    io.write('Failed to open `'..filename_out..'` for writing\n')
    os.exit(2)
  end
else
  file_out = io.stdout
end

--------------------------------------------------------------------------------

local ast = parse_file(file_in)

io.write('--------------------------------------------------------------------------------\n')
ast_dump(ast)
io.write('--------------------------------------------------------------------------------\n')
ir = compile_ir(ast)
io.write('--------------------------------------------------------------------------------\n')
ir_dump(ir)
io.write('--------------------------------------------------------------------------------\n')

generate(ir, file_out)

